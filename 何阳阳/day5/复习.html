<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

</body>

</html>
<script>
    function sum(a, b) {
        //在私有作用域中，形参赋值先于变量提升
        var a = 10;
        return a + b;
    }
    var t = sum(1 + 2);
    console.log(t);//NaN

    /*
    全局作用域    全局变量
    私有作用域（函数执行，形成私有作用域） 私有变量（声明过的，形参）
    块级作用域    用{}包起来的部分   只对let和const声明的变量起作用

    let(const)和var的区别
    1、let声明的变量不会挂载到windows下
    2、let没有变量提升
    console.log(q);
    var q = 12;//undefined
    console.log(a);
    let a = 12;//出错
    3、let能识别块级作用域
    4、let不能重复声明
    */

    for (var i = 0; i < 4; i++) {
        var a = 12;
    }
    console.log(a);//12

    /*上级作用域
    一个函数执行：他的上级作用域跟 这个函数在哪里执行没关系
    只跟这个函数在哪里定义有关系，在哪个作用域定义的
    他的上级作用域就是谁
    */

    /*作用域链
    它是一个变量的查找机制，自己的作用域没有时，就往上级找，直到找到这个变量
    当找至 全局变量时，仍没有找到这个变量，这是就会报错
    */
    var a = 100;
    function fn() {
        var a = 12;
        console.log(a);//12
        return function () {
            console.log(a);//12
        }
    }
    let f = fn();
    f();

    //常见前端面试题
    var n = 10;
    function outer() {
        var n = 15;
        function inner(n) {
            console.log(n)
            function center() {
                n++;
                console.log(n);
            }
            center();
        }
        inner(n);
    }
    outer();

    let b = 10;
    function fn2() {
        console.log(b);//暂时性死去
        // let b = 12;
    }
    fn2();

</script>